// This file is @generated by prost-build.
/// RPCError represents a generic non-internal error.
///
/// Receivers of any ResponseMessage are expected to check whether its error field is not null.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpcError {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpcBlock {
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<RpcBlockHeader>,
    #[prost(message, repeated, tag = "2")]
    pub transactions: ::prost::alloc::vec::Vec<RpcTransaction>,
    #[prost(message, optional, tag = "3")]
    pub verbose_data: ::core::option::Option<RpcBlockVerboseData>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpcBlockHeader {
    #[prost(uint32, tag = "1")]
    pub version: u32,
    #[prost(message, repeated, tag = "12")]
    pub parents: ::prost::alloc::vec::Vec<RpcBlockLevelParents>,
    #[prost(string, tag = "3")]
    pub hash_merkle_root: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub accepted_id_merkle_root: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub utxo_commitment: ::prost::alloc::string::String,
    #[prost(int64, tag = "6")]
    pub timestamp: i64,
    #[prost(uint32, tag = "7")]
    pub bits: u32,
    #[prost(uint64, tag = "8")]
    pub nonce: u64,
    #[prost(uint64, tag = "9")]
    pub daa_score: u64,
    #[prost(string, tag = "10")]
    pub blue_work: ::prost::alloc::string::String,
    #[prost(string, tag = "14")]
    pub pruning_point: ::prost::alloc::string::String,
    #[prost(uint64, tag = "13")]
    pub blue_score: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpcBlockLevelParents {
    #[prost(string, repeated, tag = "1")]
    pub parent_hashes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpcBlockVerboseData {
    #[prost(string, tag = "1")]
    pub hash: ::prost::alloc::string::String,
    #[prost(double, tag = "11")]
    pub difficulty: f64,
    #[prost(string, tag = "13")]
    pub selected_parent_hash: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "14")]
    pub transaction_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "15")]
    pub is_header_only: bool,
    #[prost(uint64, tag = "16")]
    pub blue_score: u64,
    #[prost(string, repeated, tag = "17")]
    pub children_hashes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "18")]
    pub merge_set_blues_hashes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "19")]
    pub merge_set_reds_hashes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "20")]
    pub is_chain_block: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpcTransaction {
    #[prost(uint32, tag = "1")]
    pub version: u32,
    #[prost(message, repeated, tag = "2")]
    pub inputs: ::prost::alloc::vec::Vec<RpcTransactionInput>,
    #[prost(message, repeated, tag = "3")]
    pub outputs: ::prost::alloc::vec::Vec<RpcTransactionOutput>,
    #[prost(uint64, tag = "4")]
    pub lock_time: u64,
    #[prost(string, tag = "5")]
    pub subnetwork_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "6")]
    pub gas: u64,
    #[prost(string, tag = "8")]
    pub payload: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "9")]
    pub verbose_data: ::core::option::Option<RpcTransactionVerboseData>,
    #[prost(uint64, tag = "10")]
    pub mass: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpcTransactionInput {
    #[prost(message, optional, tag = "1")]
    pub previous_outpoint: ::core::option::Option<RpcOutpoint>,
    #[prost(string, tag = "2")]
    pub signature_script: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub sequence: u64,
    #[prost(uint32, tag = "5")]
    pub sig_op_count: u32,
    #[prost(message, optional, tag = "4")]
    pub verbose_data: ::core::option::Option<RpcTransactionInputVerboseData>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpcScriptPublicKey {
    #[prost(uint32, tag = "1")]
    pub version: u32,
    #[prost(string, tag = "2")]
    pub script_public_key: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpcTransactionOutput {
    #[prost(uint64, tag = "1")]
    pub amount: u64,
    #[prost(message, optional, tag = "2")]
    pub script_public_key: ::core::option::Option<RpcScriptPublicKey>,
    #[prost(message, optional, tag = "3")]
    pub verbose_data: ::core::option::Option<RpcTransactionOutputVerboseData>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpcOutpoint {
    #[prost(string, tag = "1")]
    pub transaction_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub index: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpcUtxoEntry {
    #[prost(uint64, tag = "1")]
    pub amount: u64,
    #[prost(message, optional, tag = "2")]
    pub script_public_key: ::core::option::Option<RpcScriptPublicKey>,
    #[prost(uint64, tag = "3")]
    pub block_daa_score: u64,
    #[prost(bool, tag = "4")]
    pub is_coinbase: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpcTransactionVerboseData {
    #[prost(string, tag = "1")]
    pub transaction_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub hash: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub compute_mass: u64,
    #[prost(string, tag = "12")]
    pub block_hash: ::prost::alloc::string::String,
    #[prost(uint64, tag = "14")]
    pub block_time: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpcTransactionInputVerboseData {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpcTransactionOutputVerboseData {
    #[prost(string, tag = "5")]
    pub script_public_key_type: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub script_public_key_address: ::prost::alloc::string::String,
}
/// GetCurrentNetworkRequestMessage requests the network entropyx is currently running against.
///
/// Possible networks are: Mainnet, Testnet, Simnet, Devnet
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCurrentNetworkRequestMessage {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCurrentNetworkResponseMessage {
    #[prost(string, tag = "1")]
    pub current_network: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// SubmitBlockRequestMessage requests to submit a block into the DAG.
/// Blocks are generally expected to have been generated using the getBlockTemplate call.
///
/// See: GetBlockTemplateRequestMessage
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitBlockRequestMessage {
    #[prost(message, optional, tag = "2")]
    pub block: ::core::option::Option<RpcBlock>,
    #[prost(bool, tag = "3")]
    pub allow_non_daa_blocks: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitBlockResponseMessage {
    #[prost(enumeration = "submit_block_response_message::RejectReason", tag = "1")]
    pub reject_reason: i32,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// Nested message and enum types in `SubmitBlockResponseMessage`.
pub mod submit_block_response_message {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RejectReason {
        None = 0,
        BlockInvalid = 1,
        IsInIbd = 2,
    }
    impl RejectReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RejectReason::None => "NONE",
                RejectReason::BlockInvalid => "BLOCK_INVALID",
                RejectReason::IsInIbd => "IS_IN_IBD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "BLOCK_INVALID" => Some(Self::BlockInvalid),
                "IS_IN_IBD" => Some(Self::IsInIbd),
                _ => None,
            }
        }
    }
}
/// GetBlockTemplateRequestMessage requests a current block template.
/// Callers are expected to solve the block template and submit it using the submitBlock call
///
/// See: SubmitBlockRequestMessage
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlockTemplateRequestMessage {
    /// Which entropyx address should the coinbase block reward transaction pay into
    #[prost(string, tag = "1")]
    pub pay_address: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub extra_data: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlockTemplateResponseMessage {
    #[prost(message, optional, tag = "3")]
    pub block: ::core::option::Option<RpcBlock>,
    /// Whether entropyx thinks that it's synced.
    /// Callers are discouraged (but not forbidden) from solving blocks when entropyx is not synced.
    /// That is because when entropyx isn't in sync with the rest of the network there's a high
    /// chance the block will never be accepted, thus the solving effort would have been wasted.
    #[prost(bool, tag = "2")]
    pub is_synced: bool,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// NotifyBlockAddedRequestMessage registers this connection for blockAdded notifications.
///
/// See: BlockAddedNotificationMessage
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyBlockAddedRequestMessage {
    #[prost(enumeration = "RpcNotifyCommand", tag = "101")]
    pub command: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyBlockAddedResponseMessage {
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// BlockAddedNotificationMessage is sent whenever a blocks has been added (NOT accepted)
/// into the DAG.
///
/// See: NotifyBlockAddedRequestMessage
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockAddedNotificationMessage {
    #[prost(message, optional, tag = "3")]
    pub block: ::core::option::Option<RpcBlock>,
}
/// GetPeerAddressesRequestMessage requests the list of known entropyx addresses in the
/// current network. (mainnet, testnet, etc.)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPeerAddressesRequestMessage {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPeerAddressesResponseMessage {
    #[prost(message, repeated, tag = "1")]
    pub addresses: ::prost::alloc::vec::Vec<GetPeerAddressesKnownAddressMessage>,
    #[prost(message, repeated, tag = "2")]
    pub banned_addresses: ::prost::alloc::vec::Vec<GetPeerAddressesKnownAddressMessage>,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPeerAddressesKnownAddressMessage {
    #[prost(string, tag = "1")]
    pub addr: ::prost::alloc::string::String,
}
/// GetSinkRequestMessage requests the hash of the current virtual's
/// selected parent.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSinkRequestMessage {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSinkResponseMessage {
    #[prost(string, tag = "1")]
    pub sink: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// GetMempoolEntryRequestMessage requests information about a specific transaction
/// in the mempool.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMempoolEntryRequestMessage {
    /// The transaction's TransactionID.
    #[prost(string, tag = "1")]
    pub tx_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub include_orphan_pool: bool,
    #[prost(bool, tag = "3")]
    pub filter_transaction_pool: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMempoolEntryResponseMessage {
    #[prost(message, optional, tag = "1")]
    pub entry: ::core::option::Option<RpcMempoolEntry>,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// GetMempoolEntriesRequestMessage requests information about all the transactions
/// currently in the mempool.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMempoolEntriesRequestMessage {
    #[prost(bool, tag = "1")]
    pub include_orphan_pool: bool,
    #[prost(bool, tag = "2")]
    pub filter_transaction_pool: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMempoolEntriesResponseMessage {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<RpcMempoolEntry>,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpcMempoolEntry {
    #[prost(uint64, tag = "1")]
    pub fee: u64,
    #[prost(message, optional, tag = "3")]
    pub transaction: ::core::option::Option<RpcTransaction>,
    #[prost(bool, tag = "4")]
    pub is_orphan: bool,
}
/// GetConnectedPeerInfoRequestMessage requests information about all the p2p peers
/// currently connected to this entropyx.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConnectedPeerInfoRequestMessage {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConnectedPeerInfoResponseMessage {
    #[prost(message, repeated, tag = "1")]
    pub infos: ::prost::alloc::vec::Vec<GetConnectedPeerInfoMessage>,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConnectedPeerInfoMessage {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub address: ::prost::alloc::string::String,
    /// How long did the last ping/pong exchange take
    #[prost(int64, tag = "3")]
    pub last_ping_duration: i64,
    /// Whether this entropyx initiated the connection
    #[prost(bool, tag = "6")]
    pub is_outbound: bool,
    #[prost(int64, tag = "7")]
    pub time_offset: i64,
    #[prost(string, tag = "8")]
    pub user_agent: ::prost::alloc::string::String,
    /// The protocol version that this peer claims to support
    #[prost(uint32, tag = "9")]
    pub advertised_protocol_version: u32,
    /// The timestamp of when this peer connected to this entropyx
    #[prost(int64, tag = "10")]
    pub time_connected: i64,
    /// Whether this peer is the IBD peer (if IBD is running)
    #[prost(bool, tag = "11")]
    pub is_ibd_peer: bool,
}
/// AddPeerRequestMessage adds a peer to entropyx's outgoing connection list.
/// This will, in most cases, result in entropyx connecting to said peer.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddPeerRequestMessage {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    /// Whether to keep attempting to connect to this peer after disconnection
    #[prost(bool, tag = "2")]
    pub is_permanent: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddPeerResponseMessage {
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// SubmitTransactionRequestMessage submits a transaction to the mempool
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitTransactionRequestMessage {
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<RpcTransaction>,
    #[prost(bool, tag = "2")]
    pub allow_orphan: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitTransactionResponseMessage {
    /// The transaction ID of the submitted transaction
    #[prost(string, tag = "1")]
    pub transaction_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// SubmitTransactionReplacementRequestMessage submits a transaction to the mempool, applying a mandatory Replace by Fee policy
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitTransactionReplacementRequestMessage {
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<RpcTransaction>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitTransactionReplacementResponseMessage {
    /// The transaction ID of the submitted transaction
    #[prost(string, tag = "1")]
    pub transaction_id: ::prost::alloc::string::String,
    /// The previous transaction replaced in the mempool by the newly submitted one
    #[prost(message, optional, tag = "2")]
    pub replaced_transaction: ::core::option::Option<RpcTransaction>,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// NotifyVirtualChainChangedRequestMessage registers this connection for virtualChainChanged notifications.
///
/// See: VirtualChainChangedNotificationMessage
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyVirtualChainChangedRequestMessage {
    #[prost(bool, tag = "1")]
    pub include_accepted_transaction_ids: bool,
    #[prost(enumeration = "RpcNotifyCommand", tag = "101")]
    pub command: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyVirtualChainChangedResponseMessage {
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// VirtualChainChangedNotificationMessage is sent whenever the DAG's selected parent
/// chain had changed.
///
/// See: NotifyVirtualChainChangedRequestMessage
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VirtualChainChangedNotificationMessage {
    /// The chain blocks that were removed, in high-to-low order
    #[prost(string, repeated, tag = "1")]
    pub removed_chain_block_hashes: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// The chain blocks that were added, in low-to-high order
    #[prost(string, repeated, tag = "3")]
    pub added_chain_block_hashes: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Will be filled only if `includeAcceptedTransactionIds = true` in the notify request.
    #[prost(message, repeated, tag = "2")]
    pub accepted_transaction_ids: ::prost::alloc::vec::Vec<RpcAcceptedTransactionIds>,
}
/// GetBlockRequestMessage requests information about a specific block
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlockRequestMessage {
    /// The hash of the requested block
    #[prost(string, tag = "1")]
    pub hash: ::prost::alloc::string::String,
    /// Whether to include transaction data in the response
    #[prost(bool, tag = "3")]
    pub include_transactions: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlockResponseMessage {
    #[prost(message, optional, tag = "3")]
    pub block: ::core::option::Option<RpcBlock>,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// GetSubnetworkRequestMessage requests information about a specific subnetwork
///
/// Currently unimplemented
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSubnetworkRequestMessage {
    #[prost(string, tag = "1")]
    pub subnetwork_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSubnetworkResponseMessage {
    #[prost(uint64, tag = "1")]
    pub gas_limit: u64,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// / GetVirtualChainFromBlockRequestMessage requests the virtual selected
/// / parent chain from some startHash to this entropyx's current virtual
/// / Note:
/// /     this call batches the response to:
/// /         a. the network's `mergeset size limit * 10` amount of added chain blocks, if `includeAcceptedTransactionIds = false`
/// /         b. or `mergeset size limit * 10` amount of merged blocks, if `includeAcceptedTransactionIds = true`
/// /         c. it does not batch the removed chain blocks, only the added ones.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVirtualChainFromBlockRequestMessage {
    #[prost(string, tag = "1")]
    pub start_hash: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub include_accepted_transaction_ids: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpcAcceptedTransactionIds {
    #[prost(string, tag = "1")]
    pub accepting_block_hash: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub accepted_transaction_ids: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVirtualChainFromBlockResponseMessage {
    /// The chain blocks that were removed, in high-to-low order
    #[prost(string, repeated, tag = "1")]
    pub removed_chain_block_hashes: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// The chain blocks that were added, in low-to-high order
    #[prost(string, repeated, tag = "3")]
    pub added_chain_block_hashes: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// The transactions accepted by each block in addedChainBlockHashes.
    /// Will be filled only if `includeAcceptedTransactionIds = true` in the request.
    #[prost(message, repeated, tag = "2")]
    pub accepted_transaction_ids: ::prost::alloc::vec::Vec<RpcAcceptedTransactionIds>,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// GetBlocksRequestMessage requests blocks between a certain block lowHash up to this
/// entropyx's current virtual.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlocksRequestMessage {
    #[prost(string, tag = "1")]
    pub low_hash: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub include_blocks: bool,
    #[prost(bool, tag = "3")]
    pub include_transactions: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlocksResponseMessage {
    #[prost(string, repeated, tag = "4")]
    pub block_hashes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "3")]
    pub blocks: ::prost::alloc::vec::Vec<RpcBlock>,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// GetBlockCountRequestMessage requests the current number of blocks in this entropyx.
/// Note that this number may decrease as pruning occurs.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlockCountRequestMessage {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlockCountResponseMessage {
    #[prost(uint64, tag = "1")]
    pub block_count: u64,
    #[prost(uint64, tag = "2")]
    pub header_count: u64,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// GetBlockDagInfoRequestMessage requests general information about the current state
/// of this entropyx's DAG.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlockDagInfoRequestMessage {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlockDagInfoResponseMessage {
    #[prost(string, tag = "1")]
    pub network_name: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub block_count: u64,
    #[prost(uint64, tag = "3")]
    pub header_count: u64,
    #[prost(string, repeated, tag = "4")]
    pub tip_hashes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(double, tag = "5")]
    pub difficulty: f64,
    #[prost(int64, tag = "6")]
    pub past_median_time: i64,
    #[prost(string, repeated, tag = "7")]
    pub virtual_parent_hashes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "8")]
    pub pruning_point_hash: ::prost::alloc::string::String,
    #[prost(uint64, tag = "9")]
    pub virtual_daa_score: u64,
    #[prost(string, tag = "10")]
    pub sink: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResolveFinalityConflictRequestMessage {
    #[prost(string, tag = "1")]
    pub finality_block_hash: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResolveFinalityConflictResponseMessage {
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyFinalityConflictRequestMessage {
    #[prost(enumeration = "RpcNotifyCommand", tag = "101")]
    pub command: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyFinalityConflictResponseMessage {
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FinalityConflictNotificationMessage {
    #[prost(string, tag = "1")]
    pub violating_block_hash: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FinalityConflictResolvedNotificationMessage {
    #[prost(string, tag = "1")]
    pub finality_block_hash: ::prost::alloc::string::String,
}
/// ShutdownRequestMessage shuts down this entropyx.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShutdownRequestMessage {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShutdownResponseMessage {
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// GetHeadersRequestMessage requests headers between the given startHash and the
/// current virtual, up to the given limit.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHeadersRequestMessage {
    #[prost(string, tag = "1")]
    pub start_hash: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub limit: u64,
    #[prost(bool, tag = "3")]
    pub is_ascending: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHeadersResponseMessage {
    #[prost(string, repeated, tag = "1")]
    pub headers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// NotifyUtxosChangedRequestMessage registers this connection for utxoChanged notifications
/// for the given addresses.
///
/// This call is only available when this entropyx was started with `--utxoindex`
///
/// See: UtxosChangedNotificationMessage
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyUtxosChangedRequestMessage {
    /// UTXOs addresses to start/stop getting notified about
    /// Leave empty to start/stop all updates
    #[prost(string, repeated, tag = "1")]
    pub addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration = "RpcNotifyCommand", tag = "101")]
    pub command: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyUtxosChangedResponseMessage {
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// UtxosChangedNotificationMessage is sent whenever the UTXO index had been updated.
///
/// See: NotifyUtxosChangedRequestMessage
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UtxosChangedNotificationMessage {
    #[prost(message, repeated, tag = "1")]
    pub added: ::prost::alloc::vec::Vec<RpcUtxosByAddressesEntry>,
    #[prost(message, repeated, tag = "2")]
    pub removed: ::prost::alloc::vec::Vec<RpcUtxosByAddressesEntry>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpcUtxosByAddressesEntry {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub outpoint: ::core::option::Option<RpcOutpoint>,
    #[prost(message, optional, tag = "3")]
    pub utxo_entry: ::core::option::Option<RpcUtxoEntry>,
}
/// StopNotifyingUtxosChangedRequestMessage unregisters this connection for utxoChanged notifications
/// for the given addresses.
///
/// This call is only available when this entropyx was started with `--utxoindex`
///
/// See: UtxosChangedNotificationMessage
///
/// This message only exists for backward compatibility reason with entropyx and is deprecated.
/// Use instead UtxosChangedNotificationMessage with command = NOTIFY_STOP.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopNotifyingUtxosChangedRequestMessage {
    #[prost(string, repeated, tag = "1")]
    pub addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopNotifyingUtxosChangedResponseMessage {
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// GetUtxosByAddressesRequestMessage requests all current UTXOs for the given entropyx addresses
///
/// This call is only available when this entropyx was started with `--utxoindex`
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUtxosByAddressesRequestMessage {
    #[prost(string, repeated, tag = "1")]
    pub addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUtxosByAddressesResponseMessage {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<RpcUtxosByAddressesEntry>,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// GetBalanceByAddressRequest returns the total balance in unspent transactions towards a given address
///
/// This call is only available when this entropyx was started with `--utxoindex`
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBalanceByAddressRequestMessage {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBalanceByAddressResponseMessage {
    #[prost(uint64, tag = "1")]
    pub balance: u64,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBalancesByAddressesRequestMessage {
    #[prost(string, repeated, tag = "1")]
    pub addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpcBalancesByAddressesEntry {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub balance: u64,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBalancesByAddressesResponseMessage {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<RpcBalancesByAddressesEntry>,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// GetSinkBlueScoreRequestMessage requests the blue score of the current selected parent
/// of the virtual block.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSinkBlueScoreRequestMessage {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSinkBlueScoreResponseMessage {
    #[prost(uint64, tag = "1")]
    pub blue_score: u64,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// NotifySinkBlueScoreChangedRequestMessage registers this connection for
/// sinkBlueScoreChanged notifications.
///
/// See: SinkBlueScoreChangedNotificationMessage
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifySinkBlueScoreChangedRequestMessage {
    #[prost(enumeration = "RpcNotifyCommand", tag = "101")]
    pub command: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifySinkBlueScoreChangedResponseMessage {
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// SinkBlueScoreChangedNotificationMessage is sent whenever the blue score
/// of the virtual's selected parent changes.
///
/// See NotifySinkBlueScoreChangedRequestMessage
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SinkBlueScoreChangedNotificationMessage {
    #[prost(uint64, tag = "1")]
    pub sink_blue_score: u64,
}
/// NotifyVirtualDaaScoreChangedRequestMessage registers this connection for
/// virtualDaaScoreChanged notifications.
///
/// See: VirtualDaaScoreChangedNotificationMessage
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyVirtualDaaScoreChangedRequestMessage {
    #[prost(enumeration = "RpcNotifyCommand", tag = "101")]
    pub command: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyVirtualDaaScoreChangedResponseMessage {
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// VirtualDaaScoreChangedNotificationMessage is sent whenever the DAA score
/// of the virtual changes.
///
/// See NotifyVirtualDaaScoreChangedRequestMessage
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VirtualDaaScoreChangedNotificationMessage {
    #[prost(uint64, tag = "1")]
    pub virtual_daa_score: u64,
}
/// NotifyPruningPointUtxoSetOverrideRequestMessage registers this connection for
/// pruning point UTXO set override notifications.
///
/// This call is only available when this entropyx was started with `--utxoindex`
///
/// See: NotifyPruningPointUtxoSetOverrideResponseMessage
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyPruningPointUtxoSetOverrideRequestMessage {
    #[prost(enumeration = "RpcNotifyCommand", tag = "101")]
    pub command: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyPruningPointUtxoSetOverrideResponseMessage {
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// PruningPointUtxoSetOverrideNotificationMessage is sent whenever the UTXO index
/// resets due to pruning point change via IBD.
///
/// See NotifyPruningPointUtxoSetOverrideRequestMessage
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PruningPointUtxoSetOverrideNotificationMessage {}
/// StopNotifyingPruningPointUtxoSetOverrideRequestMessage unregisters this connection for
/// pruning point UTXO set override notifications.
///
/// This call is only available when this entropyx was started with `--utxoindex`
///
/// See: PruningPointUtxoSetOverrideNotificationMessage
///
/// This message only exists for backward compatibility reason with entropyx and is deprecated.
/// Use instead NotifyPruningPointUtxoSetOverrideRequestMessage with command = NOTIFY_STOP.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopNotifyingPruningPointUtxoSetOverrideRequestMessage {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopNotifyingPruningPointUtxoSetOverrideResponseMessage {
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// BanRequestMessage bans the given ip.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BanRequestMessage {
    #[prost(string, tag = "1")]
    pub ip: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BanResponseMessage {
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// UnbanRequestMessage unbans the given ip.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnbanRequestMessage {
    #[prost(string, tag = "1")]
    pub ip: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnbanResponseMessage {
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// GetInfoRequestMessage returns info about the node.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInfoRequestMessage {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInfoResponseMessage {
    #[prost(string, tag = "1")]
    pub p2p_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub mempool_size: u64,
    #[prost(string, tag = "3")]
    pub server_version: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub is_utxo_indexed: bool,
    #[prost(bool, tag = "5")]
    pub is_synced: bool,
    #[prost(bool, tag = "11")]
    pub has_notify_command: bool,
    #[prost(bool, tag = "12")]
    pub has_message_id: bool,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EstimateNetworkHashesPerSecondRequestMessage {
    #[prost(uint32, tag = "1")]
    pub window_size: u32,
    #[prost(string, tag = "2")]
    pub start_hash: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EstimateNetworkHashesPerSecondResponseMessage {
    #[prost(uint64, tag = "1")]
    pub network_hashes_per_second: u64,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// NotifyNewBlockTemplateRequestMessage registers this connection for
/// NewBlockTemplate notifications.
///
/// See: NewBlockTemplateNotificationMessage
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyNewBlockTemplateRequestMessage {
    #[prost(enumeration = "RpcNotifyCommand", tag = "101")]
    pub command: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyNewBlockTemplateResponseMessage {
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// NewBlockTemplateNotificationMessage is sent whenever a new updated block template is
/// available for miners.
///
/// See NotifyNewBlockTemplateRequestMessage
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NewBlockTemplateNotificationMessage {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpcMempoolEntryByAddress {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub sending: ::prost::alloc::vec::Vec<RpcMempoolEntry>,
    #[prost(message, repeated, tag = "3")]
    pub receiving: ::prost::alloc::vec::Vec<RpcMempoolEntry>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMempoolEntriesByAddressesRequestMessage {
    #[prost(string, repeated, tag = "1")]
    pub addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "2")]
    pub include_orphan_pool: bool,
    #[prost(bool, tag = "3")]
    pub filter_transaction_pool: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMempoolEntriesByAddressesResponseMessage {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<RpcMempoolEntryByAddress>,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCoinSupplyRequestMessage {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCoinSupplyResponseMessage {
    /// note: this is a hard coded maxSupply, actual maxSupply is expected to deviate by upto -5%, but cannot be measured exactly.
    #[prost(uint64, tag = "1")]
    pub max_sompi: u64,
    #[prost(uint64, tag = "2")]
    pub circulating_sompi: u64,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PingRequestMessage {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PingResponseMessage {
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessMetrics {
    #[prost(uint64, tag = "1")]
    pub resident_set_size: u64,
    #[prost(uint64, tag = "2")]
    pub virtual_memory_size: u64,
    #[prost(uint32, tag = "3")]
    pub core_num: u32,
    #[prost(float, tag = "4")]
    pub cpu_usage: f32,
    #[prost(uint32, tag = "5")]
    pub fd_num: u32,
    #[prost(uint64, tag = "6")]
    pub disk_io_read_bytes: u64,
    #[prost(uint64, tag = "7")]
    pub disk_io_write_bytes: u64,
    #[prost(float, tag = "8")]
    pub disk_io_read_per_sec: f32,
    #[prost(float, tag = "9")]
    pub disk_io_write_per_sec: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectionMetrics {
    #[prost(uint32, tag = "31")]
    pub borsh_live_connections: u32,
    #[prost(uint64, tag = "32")]
    pub borsh_connection_attempts: u64,
    #[prost(uint64, tag = "33")]
    pub borsh_handshake_failures: u64,
    #[prost(uint32, tag = "41")]
    pub json_live_connections: u32,
    #[prost(uint64, tag = "42")]
    pub json_connection_attempts: u64,
    #[prost(uint64, tag = "43")]
    pub json_handshake_failures: u64,
    #[prost(uint32, tag = "51")]
    pub active_peers: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BandwidthMetrics {
    #[prost(uint64, tag = "61")]
    pub borsh_bytes_tx: u64,
    #[prost(uint64, tag = "62")]
    pub borsh_bytes_rx: u64,
    #[prost(uint64, tag = "63")]
    pub json_bytes_tx: u64,
    #[prost(uint64, tag = "64")]
    pub json_bytes_rx: u64,
    #[prost(uint64, tag = "65")]
    pub grpc_p2p_bytes_tx: u64,
    #[prost(uint64, tag = "66")]
    pub grpc_p2p_bytes_rx: u64,
    #[prost(uint64, tag = "67")]
    pub grpc_user_bytes_tx: u64,
    #[prost(uint64, tag = "68")]
    pub grpc_user_bytes_rx: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusMetrics {
    #[prost(uint64, tag = "1")]
    pub blocks_submitted: u64,
    #[prost(uint64, tag = "2")]
    pub header_counts: u64,
    #[prost(uint64, tag = "3")]
    pub dep_counts: u64,
    #[prost(uint64, tag = "4")]
    pub body_counts: u64,
    #[prost(uint64, tag = "5")]
    pub txs_counts: u64,
    #[prost(uint64, tag = "6")]
    pub chain_block_counts: u64,
    #[prost(uint64, tag = "7")]
    pub mass_counts: u64,
    #[prost(uint64, tag = "11")]
    pub block_count: u64,
    #[prost(uint64, tag = "12")]
    pub header_count: u64,
    #[prost(uint64, tag = "13")]
    pub mempool_size: u64,
    #[prost(uint32, tag = "14")]
    pub tip_hashes_count: u32,
    #[prost(double, tag = "15")]
    pub difficulty: f64,
    #[prost(uint64, tag = "16")]
    pub past_median_time: u64,
    #[prost(uint32, tag = "17")]
    pub virtual_parent_hashes_count: u32,
    #[prost(uint64, tag = "18")]
    pub virtual_daa_score: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StorageMetrics {
    #[prost(uint64, tag = "1")]
    pub storage_size_bytes: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConnectionsRequestMessage {
    #[prost(bool, tag = "1")]
    pub include_profile_data: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectionsProfileData {
    #[prost(double, tag = "1")]
    pub cpu_usage: f64,
    #[prost(uint64, tag = "2")]
    pub memory_usage: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConnectionsResponseMessage {
    #[prost(uint32, tag = "1")]
    pub clients: u32,
    #[prost(uint32, tag = "2")]
    pub peers: u32,
    #[prost(message, optional, tag = "3")]
    pub profile_data: ::core::option::Option<ConnectionsProfileData>,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSystemInfoRequestMessage {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSystemInfoResponseMessage {
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub system_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub git_hash: ::prost::alloc::string::String,
    #[prost(uint32, tag = "4")]
    pub core_num: u32,
    #[prost(uint64, tag = "5")]
    pub total_memory: u64,
    #[prost(uint32, tag = "6")]
    pub fd_limit: u32,
    #[prost(uint32, tag = "7")]
    pub proxy_socket_limit_per_cpu_core: u32,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMetricsRequestMessage {
    #[prost(bool, tag = "1")]
    pub process_metrics: bool,
    #[prost(bool, tag = "2")]
    pub connection_metrics: bool,
    #[prost(bool, tag = "3")]
    pub bandwidth_metrics: bool,
    #[prost(bool, tag = "4")]
    pub consensus_metrics: bool,
    #[prost(bool, tag = "5")]
    pub storage_metrics: bool,
    #[prost(bool, tag = "6")]
    pub custom_metrics: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMetricsResponseMessage {
    #[prost(uint64, tag = "1")]
    pub server_time: u64,
    #[prost(message, optional, tag = "11")]
    pub process_metrics: ::core::option::Option<ProcessMetrics>,
    #[prost(message, optional, tag = "12")]
    pub connection_metrics: ::core::option::Option<ConnectionMetrics>,
    #[prost(message, optional, tag = "13")]
    pub bandwidth_metrics: ::core::option::Option<BandwidthMetrics>,
    #[prost(message, optional, tag = "14")]
    pub consensus_metrics: ::core::option::Option<ConsensusMetrics>,
    #[prost(message, optional, tag = "15")]
    pub storage_metrics: ::core::option::Option<StorageMetrics>,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetServerInfoRequestMessage {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetServerInfoResponseMessage {
    #[prost(uint32, tag = "1")]
    pub rpc_api_version: u32,
    #[prost(uint32, tag = "2")]
    pub rpc_api_revision: u32,
    #[prost(string, tag = "3")]
    pub server_version: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub network_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub has_utxo_index: bool,
    #[prost(bool, tag = "6")]
    pub is_synced: bool,
    #[prost(uint64, tag = "7")]
    pub virtual_daa_score: u64,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSyncStatusRequestMessage {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSyncStatusResponseMessage {
    #[prost(bool, tag = "1")]
    pub is_synced: bool,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDaaScoreTimestampEstimateRequestMessage {
    #[prost(uint64, repeated, tag = "1")]
    pub daa_scores: ::prost::alloc::vec::Vec<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDaaScoreTimestampEstimateResponseMessage {
    #[prost(uint64, repeated, tag = "1")]
    pub timestamps: ::prost::alloc::vec::Vec<u64>,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpcFeerateBucket {
    /// Fee/mass of a transaction in `sompi/gram` units
    #[prost(double, tag = "1")]
    pub feerate: f64,
    #[prost(double, tag = "2")]
    pub estimated_seconds: f64,
}
/// Data required for making fee estimates.
///
/// Feerate values represent fee/mass of a transaction in `sompi/gram` units.
/// Given a feerate value recommendation, calculate the required fee by
/// taking the transaction mass and multiplying it by feerate: `fee = feerate * mass(tx)`
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpcFeeEstimate {
    /// Top-priority feerate bucket. Provides an estimation of the feerate required for sub-second DAG inclusion.
    #[prost(message, optional, tag = "1")]
    pub priority_bucket: ::core::option::Option<RpcFeerateBucket>,
    /// A vector of *normal* priority feerate values. The first value of this vector is guaranteed to exist and
    /// provide an estimation for sub-*minute* DAG inclusion. All other values will have shorter estimation
    /// times than all `lowBucket` values. Therefor by chaining `\[priority\] | normal | low` and interpolating
    /// between them, one can compose a complete feerate function on the client side. The API makes an effort
    /// to sample enough "interesting" points on the feerate-to-time curve, so that the interpolation is meaningful.
    #[prost(message, repeated, tag = "2")]
    pub normal_buckets: ::prost::alloc::vec::Vec<RpcFeerateBucket>,
    /// A vector of *low* priority feerate values. The first value of this vector is guaranteed to
    /// exist and provide an estimation for sub-*hour* DAG inclusion.
    #[prost(message, repeated, tag = "3")]
    pub low_buckets: ::prost::alloc::vec::Vec<RpcFeerateBucket>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpcFeeEstimateVerboseExperimentalData {
    #[prost(uint64, tag = "1")]
    pub mempool_ready_transactions_count: u64,
    #[prost(uint64, tag = "2")]
    pub mempool_ready_transactions_total_mass: u64,
    #[prost(uint64, tag = "3")]
    pub network_mass_per_second: u64,
    #[prost(double, tag = "11")]
    pub next_block_template_feerate_min: f64,
    #[prost(double, tag = "12")]
    pub next_block_template_feerate_median: f64,
    #[prost(double, tag = "13")]
    pub next_block_template_feerate_max: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFeeEstimateRequestMessage {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFeeEstimateResponseMessage {
    #[prost(message, optional, tag = "1")]
    pub estimate: ::core::option::Option<RpcFeeEstimate>,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFeeEstimateExperimentalRequestMessage {
    #[prost(bool, tag = "1")]
    pub verbose: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFeeEstimateExperimentalResponseMessage {
    #[prost(message, optional, tag = "1")]
    pub estimate: ::core::option::Option<RpcFeeEstimate>,
    #[prost(message, optional, tag = "2")]
    pub verbose: ::core::option::Option<RpcFeeEstimateVerboseExperimentalData>,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCurrentBlockColorRequestMessage {
    #[prost(string, tag = "1")]
    pub hash: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCurrentBlockColorResponseMessage {
    #[prost(bool, tag = "1")]
    pub blue: bool,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
/// / ENX-CHANGE-BURN: Burn API Request Messages
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTotalBurnedAmountRequestMessage {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTotalBurnedAmountResponseMessage {
    #[prost(uint64, tag = "1")]
    pub total_burned: u64,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBurnRecordsByRangeRequestMessage {
    #[prost(uint64, tag = "1")]
    pub start_daa: u64,
    #[prost(uint64, tag = "2")]
    pub end_daa: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBurnRecordsByRangeResponseMessage {
    #[prost(message, repeated, tag = "1")]
    pub records: ::prost::alloc::vec::Vec<RpcBurnRecord>,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBurnRecordByUtxoIdRequestMessage {
    #[prost(string, tag = "1")]
    pub utxo_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBurnRecordByUtxoIdResponseMessage {
    #[prost(message, optional, tag = "1")]
    pub record: ::core::option::Option<RpcBurnRecord>,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCurrentBurnFeeRequestMessage {
    #[prost(uint64, tag = "1")]
    pub current_daa_score: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCurrentBurnFeeResponseMessage {
    #[prost(uint64, tag = "1")]
    pub burn_fee: u64,
    #[prost(message, optional, tag = "1000")]
    pub error: ::core::option::Option<RpcError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RpcBurnRecord {
    #[prost(string, tag = "1")]
    pub block_hash: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub block_daa_score: u64,
    #[prost(uint64, tag = "3")]
    pub burned_value: u64,
    #[prost(uint64, tag = "4")]
    pub total_burned: u64,
    #[prost(uint64, tag = "5")]
    pub timestamp: u64,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RpcNotifyCommand {
    NotifyStart = 0,
    NotifyStop = 1,
}
impl RpcNotifyCommand {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            RpcNotifyCommand::NotifyStart => "NOTIFY_START",
            RpcNotifyCommand::NotifyStop => "NOTIFY_STOP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NOTIFY_START" => Some(Self::NotifyStart),
            "NOTIFY_STOP" => Some(Self::NotifyStop),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntropyXRequest {
    #[prost(uint64, tag = "101")]
    pub id: u64,
    #[prost(
        oneof = "entropy_x_request::Payload",
        tags = "1001, 1003, 1005, 1007, 1010, 1012, 1014, 1016, 1018, 1020, 1022, 1025, 1027, 1029, 1031, 1033, 1035, 1037, 1039, 1043, 1045, 1047, 1049, 1052, 1054, 1056, 1059, 1061, 1063, 1065, 1067, 1070, 1072, 1074, 1077, 1079, 1081, 1084, 1086, 1088, 1090, 1092, 1094, 1096, 1100, 1102, 1104, 1106, 1108, 1110, 1112, 1114, 1116, 1118"
    )]
    pub payload: ::core::option::Option<entropy_x_request::Payload>,
}
/// Nested message and enum types in `EntropyXRequest`.
pub mod entropy_x_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1001")]
        GetCurrentNetworkRequest(super::GetCurrentNetworkRequestMessage),
        #[prost(message, tag = "1003")]
        SubmitBlockRequest(super::SubmitBlockRequestMessage),
        #[prost(message, tag = "1005")]
        GetBlockTemplateRequest(super::GetBlockTemplateRequestMessage),
        #[prost(message, tag = "1007")]
        NotifyBlockAddedRequest(super::NotifyBlockAddedRequestMessage),
        /// BlockAddedNotificationMessage blockAddedNotification = 1009;
        #[prost(message, tag = "1010")]
        GetPeerAddressesRequest(super::GetPeerAddressesRequestMessage),
        #[prost(message, tag = "1012")]
        GetSinkRequest(super::GetSinkRequestMessage),
        #[prost(message, tag = "1014")]
        GetMempoolEntryRequest(super::GetMempoolEntryRequestMessage),
        #[prost(message, tag = "1016")]
        GetConnectedPeerInfoRequest(super::GetConnectedPeerInfoRequestMessage),
        #[prost(message, tag = "1018")]
        AddPeerRequest(super::AddPeerRequestMessage),
        #[prost(message, tag = "1020")]
        SubmitTransactionRequest(super::SubmitTransactionRequestMessage),
        #[prost(message, tag = "1022")]
        NotifyVirtualChainChangedRequest(super::NotifyVirtualChainChangedRequestMessage),
        /// VirtualChainChangedNotificationMessage virtualChainChangedNotification = 1024;
        #[prost(message, tag = "1025")]
        GetBlockRequest(super::GetBlockRequestMessage),
        #[prost(message, tag = "1027")]
        GetSubnetworkRequest(super::GetSubnetworkRequestMessage),
        #[prost(message, tag = "1029")]
        GetVirtualChainFromBlockRequest(super::GetVirtualChainFromBlockRequestMessage),
        #[prost(message, tag = "1031")]
        GetBlocksRequest(super::GetBlocksRequestMessage),
        #[prost(message, tag = "1033")]
        GetBlockCountRequest(super::GetBlockCountRequestMessage),
        #[prost(message, tag = "1035")]
        GetBlockDagInfoRequest(super::GetBlockDagInfoRequestMessage),
        #[prost(message, tag = "1037")]
        ResolveFinalityConflictRequest(super::ResolveFinalityConflictRequestMessage),
        #[prost(message, tag = "1039")]
        NotifyFinalityConflictRequest(super::NotifyFinalityConflictRequestMessage),
        /// FinalityConflictNotificationMessage finalityConflictNotification = 1041;
        /// FinalityConflictResolvedNotificationMessage finalityConflictResolvedNotification = 1042;
        #[prost(message, tag = "1043")]
        GetMempoolEntriesRequest(super::GetMempoolEntriesRequestMessage),
        #[prost(message, tag = "1045")]
        ShutdownRequest(super::ShutdownRequestMessage),
        #[prost(message, tag = "1047")]
        GetHeadersRequest(super::GetHeadersRequestMessage),
        #[prost(message, tag = "1049")]
        NotifyUtxosChangedRequest(super::NotifyUtxosChangedRequestMessage),
        /// UtxosChangedNotificationMessage utxosChangedNotification = 1051;
        #[prost(message, tag = "1052")]
        GetUtxosByAddressesRequest(super::GetUtxosByAddressesRequestMessage),
        #[prost(message, tag = "1054")]
        GetSinkBlueScoreRequest(super::GetSinkBlueScoreRequestMessage),
        #[prost(message, tag = "1056")]
        NotifySinkBlueScoreChangedRequest(
            super::NotifySinkBlueScoreChangedRequestMessage,
        ),
        /// SinkBlueScoreChangedNotificationMessage sinkBlueScoreChangedNotification = 1058;
        #[prost(message, tag = "1059")]
        BanRequest(super::BanRequestMessage),
        #[prost(message, tag = "1061")]
        UnbanRequest(super::UnbanRequestMessage),
        #[prost(message, tag = "1063")]
        GetInfoRequest(super::GetInfoRequestMessage),
        #[prost(message, tag = "1065")]
        StopNotifyingUtxosChangedRequest(super::StopNotifyingUtxosChangedRequestMessage),
        #[prost(message, tag = "1067")]
        NotifyPruningPointUtxoSetOverrideRequest(
            super::NotifyPruningPointUtxoSetOverrideRequestMessage,
        ),
        /// PruningPointUtxoSetOverrideNotificationMessage pruningPointUtxoSetOverrideNotification = 1069;
        #[prost(message, tag = "1070")]
        StopNotifyingPruningPointUtxoSetOverrideRequest(
            super::StopNotifyingPruningPointUtxoSetOverrideRequestMessage,
        ),
        #[prost(message, tag = "1072")]
        EstimateNetworkHashesPerSecondRequest(
            super::EstimateNetworkHashesPerSecondRequestMessage,
        ),
        #[prost(message, tag = "1074")]
        NotifyVirtualDaaScoreChangedRequest(
            super::NotifyVirtualDaaScoreChangedRequestMessage,
        ),
        /// VirtualDaaScoreChangedNotificationMessage virtualDaaScoreChangedNotification = 1076;
        #[prost(message, tag = "1077")]
        GetBalanceByAddressRequest(super::GetBalanceByAddressRequestMessage),
        #[prost(message, tag = "1079")]
        GetBalancesByAddressesRequest(super::GetBalancesByAddressesRequestMessage),
        #[prost(message, tag = "1081")]
        NotifyNewBlockTemplateRequest(super::NotifyNewBlockTemplateRequestMessage),
        /// NewBlockTemplateNotificationMessage newBlockTemplateNotification = 1083;
        #[prost(message, tag = "1084")]
        GetMempoolEntriesByAddressesRequest(
            super::GetMempoolEntriesByAddressesRequestMessage,
        ),
        #[prost(message, tag = "1086")]
        GetCoinSupplyRequest(super::GetCoinSupplyRequestMessage),
        #[prost(message, tag = "1088")]
        PingRequest(super::PingRequestMessage),
        #[prost(message, tag = "1090")]
        GetMetricsRequest(super::GetMetricsRequestMessage),
        #[prost(message, tag = "1092")]
        GetServerInfoRequest(super::GetServerInfoRequestMessage),
        #[prost(message, tag = "1094")]
        GetSyncStatusRequest(super::GetSyncStatusRequestMessage),
        #[prost(message, tag = "1096")]
        GetDaaScoreTimestampEstimateRequest(
            super::GetDaaScoreTimestampEstimateRequestMessage,
        ),
        #[prost(message, tag = "1100")]
        SubmitTransactionReplacementRequest(
            super::SubmitTransactionReplacementRequestMessage,
        ),
        #[prost(message, tag = "1102")]
        GetConnectionsRequest(super::GetConnectionsRequestMessage),
        #[prost(message, tag = "1104")]
        GetSystemInfoRequest(super::GetSystemInfoRequestMessage),
        #[prost(message, tag = "1106")]
        GetFeeEstimateRequest(super::GetFeeEstimateRequestMessage),
        #[prost(message, tag = "1108")]
        GetFeeEstimateExperimentalRequest(
            super::GetFeeEstimateExperimentalRequestMessage,
        ),
        #[prost(message, tag = "1110")]
        GetCurrentBlockColorRequest(super::GetCurrentBlockColorRequestMessage),
        /// ENX-CHANGE-BURN: Burn API Request Messages
        #[prost(message, tag = "1112")]
        GetTotalBurnedAmountRequest(super::GetTotalBurnedAmountRequestMessage),
        #[prost(message, tag = "1114")]
        GetBurnRecordsByRangeRequest(super::GetBurnRecordsByRangeRequestMessage),
        #[prost(message, tag = "1116")]
        GetBurnRecordByUtxoIdRequest(super::GetBurnRecordByUtxoIdRequestMessage),
        #[prost(message, tag = "1118")]
        GetCurrentBurnFeeRequest(super::GetCurrentBurnFeeRequestMessage),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntropyXResponse {
    #[prost(uint64, tag = "101")]
    pub id: u64,
    #[prost(
        oneof = "entropy_x_response::Payload",
        tags = "1002, 1004, 1006, 1008, 1009, 1011, 1013, 1015, 1017, 1019, 1021, 1023, 1024, 1026, 1028, 1030, 1032, 1034, 1036, 1038, 1040, 1041, 1042, 1044, 1046, 1048, 1050, 1051, 1053, 1055, 1057, 1058, 1060, 1062, 1064, 1066, 1068, 1069, 1071, 1073, 1075, 1076, 1078, 1080, 1082, 1083, 1085, 1087, 1089, 1091, 1093, 1095, 1097, 1101, 1103, 1105, 1107, 1109, 1111, 1113, 1115, 1117, 1119"
    )]
    pub payload: ::core::option::Option<entropy_x_response::Payload>,
}
/// Nested message and enum types in `EntropyXResponse`.
pub mod entropy_x_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1002")]
        GetCurrentNetworkResponse(super::GetCurrentNetworkResponseMessage),
        #[prost(message, tag = "1004")]
        SubmitBlockResponse(super::SubmitBlockResponseMessage),
        #[prost(message, tag = "1006")]
        GetBlockTemplateResponse(super::GetBlockTemplateResponseMessage),
        #[prost(message, tag = "1008")]
        NotifyBlockAddedResponse(super::NotifyBlockAddedResponseMessage),
        #[prost(message, tag = "1009")]
        BlockAddedNotification(super::BlockAddedNotificationMessage),
        #[prost(message, tag = "1011")]
        GetPeerAddressesResponse(super::GetPeerAddressesResponseMessage),
        #[prost(message, tag = "1013")]
        GetSinkResponse(super::GetSinkResponseMessage),
        #[prost(message, tag = "1015")]
        GetMempoolEntryResponse(super::GetMempoolEntryResponseMessage),
        #[prost(message, tag = "1017")]
        GetConnectedPeerInfoResponse(super::GetConnectedPeerInfoResponseMessage),
        #[prost(message, tag = "1019")]
        AddPeerResponse(super::AddPeerResponseMessage),
        #[prost(message, tag = "1021")]
        SubmitTransactionResponse(super::SubmitTransactionResponseMessage),
        #[prost(message, tag = "1023")]
        NotifyVirtualChainChangedResponse(
            super::NotifyVirtualChainChangedResponseMessage,
        ),
        #[prost(message, tag = "1024")]
        VirtualChainChangedNotification(super::VirtualChainChangedNotificationMessage),
        #[prost(message, tag = "1026")]
        GetBlockResponse(super::GetBlockResponseMessage),
        #[prost(message, tag = "1028")]
        GetSubnetworkResponse(super::GetSubnetworkResponseMessage),
        #[prost(message, tag = "1030")]
        GetVirtualChainFromBlockResponse(super::GetVirtualChainFromBlockResponseMessage),
        #[prost(message, tag = "1032")]
        GetBlocksResponse(super::GetBlocksResponseMessage),
        #[prost(message, tag = "1034")]
        GetBlockCountResponse(super::GetBlockCountResponseMessage),
        #[prost(message, tag = "1036")]
        GetBlockDagInfoResponse(super::GetBlockDagInfoResponseMessage),
        #[prost(message, tag = "1038")]
        ResolveFinalityConflictResponse(super::ResolveFinalityConflictResponseMessage),
        #[prost(message, tag = "1040")]
        NotifyFinalityConflictResponse(super::NotifyFinalityConflictResponseMessage),
        #[prost(message, tag = "1041")]
        FinalityConflictNotification(super::FinalityConflictNotificationMessage),
        #[prost(message, tag = "1042")]
        FinalityConflictResolvedNotification(
            super::FinalityConflictResolvedNotificationMessage,
        ),
        #[prost(message, tag = "1044")]
        GetMempoolEntriesResponse(super::GetMempoolEntriesResponseMessage),
        #[prost(message, tag = "1046")]
        ShutdownResponse(super::ShutdownResponseMessage),
        #[prost(message, tag = "1048")]
        GetHeadersResponse(super::GetHeadersResponseMessage),
        #[prost(message, tag = "1050")]
        NotifyUtxosChangedResponse(super::NotifyUtxosChangedResponseMessage),
        #[prost(message, tag = "1051")]
        UtxosChangedNotification(super::UtxosChangedNotificationMessage),
        #[prost(message, tag = "1053")]
        GetUtxosByAddressesResponse(super::GetUtxosByAddressesResponseMessage),
        #[prost(message, tag = "1055")]
        GetSinkBlueScoreResponse(super::GetSinkBlueScoreResponseMessage),
        #[prost(message, tag = "1057")]
        NotifySinkBlueScoreChangedResponse(
            super::NotifySinkBlueScoreChangedResponseMessage,
        ),
        #[prost(message, tag = "1058")]
        SinkBlueScoreChangedNotification(super::SinkBlueScoreChangedNotificationMessage),
        #[prost(message, tag = "1060")]
        BanResponse(super::BanResponseMessage),
        #[prost(message, tag = "1062")]
        UnbanResponse(super::UnbanResponseMessage),
        #[prost(message, tag = "1064")]
        GetInfoResponse(super::GetInfoResponseMessage),
        #[prost(message, tag = "1066")]
        StopNotifyingUtxosChangedResponse(
            super::StopNotifyingUtxosChangedResponseMessage,
        ),
        #[prost(message, tag = "1068")]
        NotifyPruningPointUtxoSetOverrideResponse(
            super::NotifyPruningPointUtxoSetOverrideResponseMessage,
        ),
        #[prost(message, tag = "1069")]
        PruningPointUtxoSetOverrideNotification(
            super::PruningPointUtxoSetOverrideNotificationMessage,
        ),
        #[prost(message, tag = "1071")]
        StopNotifyingPruningPointUtxoSetOverrideResponse(
            super::StopNotifyingPruningPointUtxoSetOverrideResponseMessage,
        ),
        #[prost(message, tag = "1073")]
        EstimateNetworkHashesPerSecondResponse(
            super::EstimateNetworkHashesPerSecondResponseMessage,
        ),
        #[prost(message, tag = "1075")]
        NotifyVirtualDaaScoreChangedResponse(
            super::NotifyVirtualDaaScoreChangedResponseMessage,
        ),
        #[prost(message, tag = "1076")]
        VirtualDaaScoreChangedNotification(
            super::VirtualDaaScoreChangedNotificationMessage,
        ),
        #[prost(message, tag = "1078")]
        GetBalanceByAddressResponse(super::GetBalanceByAddressResponseMessage),
        #[prost(message, tag = "1080")]
        GetBalancesByAddressesResponse(super::GetBalancesByAddressesResponseMessage),
        #[prost(message, tag = "1082")]
        NotifyNewBlockTemplateResponse(super::NotifyNewBlockTemplateResponseMessage),
        #[prost(message, tag = "1083")]
        NewBlockTemplateNotification(super::NewBlockTemplateNotificationMessage),
        #[prost(message, tag = "1085")]
        GetMempoolEntriesByAddressesResponse(
            super::GetMempoolEntriesByAddressesResponseMessage,
        ),
        #[prost(message, tag = "1087")]
        GetCoinSupplyResponse(super::GetCoinSupplyResponseMessage),
        #[prost(message, tag = "1089")]
        PingResponse(super::PingResponseMessage),
        #[prost(message, tag = "1091")]
        GetMetricsResponse(super::GetMetricsResponseMessage),
        #[prost(message, tag = "1093")]
        GetServerInfoResponse(super::GetServerInfoResponseMessage),
        #[prost(message, tag = "1095")]
        GetSyncStatusResponse(super::GetSyncStatusResponseMessage),
        #[prost(message, tag = "1097")]
        GetDaaScoreTimestampEstimateResponse(
            super::GetDaaScoreTimestampEstimateResponseMessage,
        ),
        #[prost(message, tag = "1101")]
        SubmitTransactionReplacementResponse(
            super::SubmitTransactionReplacementResponseMessage,
        ),
        #[prost(message, tag = "1103")]
        GetConnectionsResponse(super::GetConnectionsResponseMessage),
        #[prost(message, tag = "1105")]
        GetSystemInfoResponse(super::GetSystemInfoResponseMessage),
        #[prost(message, tag = "1107")]
        GetFeeEstimateResponse(super::GetFeeEstimateResponseMessage),
        #[prost(message, tag = "1109")]
        GetFeeEstimateExperimentalResponse(
            super::GetFeeEstimateExperimentalResponseMessage,
        ),
        #[prost(message, tag = "1111")]
        GetCurrentBlockColorResponse(super::GetCurrentBlockColorResponseMessage),
        /// ENX-CHANGE-BURN: Burn API Response Messages
        #[prost(message, tag = "1113")]
        GetTotalBurnedAmountResponse(super::GetTotalBurnedAmountResponseMessage),
        #[prost(message, tag = "1115")]
        GetBurnRecordsByRangeResponse(super::GetBurnRecordsByRangeResponseMessage),
        #[prost(message, tag = "1117")]
        GetBurnRecordByUtxoIdResponse(super::GetBurnRecordByUtxoIdResponseMessage),
        #[prost(message, tag = "1119")]
        GetCurrentBurnFeeResponse(super::GetCurrentBurnFeeResponseMessage),
    }
}
/// Generated client implementations.
pub mod rpc_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct RpcClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl RpcClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> RpcClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RpcClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RpcClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn message_stream(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::EntropyXRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::EntropyXResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/protowire.RPC/MessageStream",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("protowire.RPC", "MessageStream"));
            self.inner.streaming(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod rpc_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with RpcServer.
    #[async_trait]
    pub trait Rpc: Send + Sync + 'static {
        /// Server streaming response type for the MessageStream method.
        type MessageStreamStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::EntropyXResponse, tonic::Status>,
            >
            + Send
            + 'static;
        async fn message_stream(
            &self,
            request: tonic::Request<tonic::Streaming<super::EntropyXRequest>>,
        ) -> std::result::Result<
            tonic::Response<Self::MessageStreamStream>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct RpcServer<T: Rpc> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: Rpc> RpcServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for RpcServer<T>
    where
        T: Rpc,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/protowire.RPC/MessageStream" => {
                    #[allow(non_camel_case_types)]
                    struct MessageStreamSvc<T: Rpc>(pub Arc<T>);
                    impl<T: Rpc> tonic::server::StreamingService<super::EntropyXRequest>
                    for MessageStreamSvc<T> {
                        type Response = super::EntropyXResponse;
                        type ResponseStream = T::MessageStreamStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::EntropyXRequest>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Rpc>::message_stream(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = MessageStreamSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: Rpc> Clone for RpcServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: Rpc> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: Rpc> tonic::server::NamedService for RpcServer<T> {
        const NAME: &'static str = "protowire.RPC";
    }
}
